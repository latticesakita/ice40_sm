
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Propel (64-bit)
    2025.1.0.2506031608
    Soft IP Version: 1.0.0
    2025 08 21 07:25:19
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="gpio", LATTICE_IP_GENERATED="1" *) module gpio (gpio_io, 
        gpo_o, 
        gpi_o, 
        int_o, 
        ahbl_haddr_i, 
        ahbl_hburst_i, 
        ahbl_hrdata_o, 
        ahbl_hsize_i, 
        ahbl_htrans_i, 
        ahbl_hwdata_i, 
        ahbl_hready_i, 
        ahbl_hreadyout_o, 
        ahbl_hresp_o, 
        ahbl_hsel_i, 
        ahbl_hwrite_i, 
        clk_i, 
        resetn_i) ;
    inout [7:0] gpio_io ; 
    output [7:0] gpo_o ; 
    output [7:0] gpi_o ; 
    output int_o ; 
    input [31:0] ahbl_haddr_i ; 
    input [2:0] ahbl_hburst_i ; 
    output [31:0] ahbl_hrdata_o ; 
    input [2:0] ahbl_hsize_i ; 
    input [1:0] ahbl_htrans_i ; 
    input [31:0] ahbl_hwdata_i ; 
    input ahbl_hready_i ; 
    output ahbl_hreadyout_o ; 
    output ahbl_hresp_o ; 
    input ahbl_hsel_i ; 
    input ahbl_hwrite_i ; 
    input clk_i ; 
    input resetn_i ; 
    gpio_ipgen_gpio_ahbl #(.BUS_WIDTH(8),
            .DIRECTION(8'hFF),
            .INIT_OUTVAL(8'h00),
            .DEVICE("ICE40UP")) gpio_ahbl_inst (.gpio_io(gpio_io[7:0]), 
                .gpo_o(gpo_o[7:0]), 
                .gpi_o(gpi_o[7:0]), 
                .int_o(int_o), 
                .ahbl_haddr_i(ahbl_haddr_i[31:0]), 
                .ahbl_hburst_i(ahbl_hburst_i[2:0]), 
                .ahbl_hrdata_o(ahbl_hrdata_o[31:0]), 
                .ahbl_hsize_i(ahbl_hsize_i[2:0]), 
                .ahbl_htrans_i(ahbl_htrans_i[1:0]), 
                .ahbl_hwdata_i(ahbl_hwdata_i[31:0]), 
                .ahbl_hready_i(ahbl_hready_i), 
                .ahbl_hreadyout_o(ahbl_hreadyout_o), 
                .ahbl_hresp_o(ahbl_hresp_o), 
                .ahbl_hsel_i(ahbl_hsel_i), 
                .ahbl_hwrite_i(ahbl_hwrite_i), 
                .clk_i(clk_i), 
                .resetn_i(resetn_i)) ; 
endmodule



// address map
// 6'h00: RD_DATA_REG
// 6'h04: WR_DATA_REG
// 6'h08: SET_DATA_REG // upper 16bits for mask
// 6'h0c: CLEAR_DATA_REG // upper 16bits for mask
// 6'h10: DIRECTION_REG // upper 16bits for mask
// 6'h14: INT_TYPE_REG
// 6'h18: INT_METHOD_REG
// 6'h1c: INT_STATUS_REG
// 6'h20: INT_ENABLE_REG
// 6'h24: INT_SET_REG
// `define SPEED_OPTIMIZE
//`define REMOVE_TRI_STATE_BUFFER
module gpio_ipgen_gpio_ahbl #(parameter BUS_WIDTH = 8, 
        parameter DIRECTION = 'hFF, 
        parameter INIT_OUTVAL = 'h00, 
        parameter DEVICE = "CPNX") (
    // 1 for output, 0 for input
    // ICE40UP or CPNX
    inout [(BUS_WIDTH - 1):0] gpio_io, 
    output [(BUS_WIDTH - 1):0] gpo_o,  // debug purpose, IO output value
    output [(BUS_WIDTH - 1):0] gpi_o,  // debug purpose, IO input value
    output int_o, 
    input [31:0] ahbl_haddr_i,  // AHB address
    input [2:0] ahbl_hburst_i,  // unused
    output [31:0] ahbl_hrdata_o,  // AHB read data
    input [2:0] ahbl_hsize_i,  // unused
    input [1:0] ahbl_htrans_i,  // AHB transfer type
    input [31:0] ahbl_hwdata_i,  // AHB write data
    input ahbl_hready_i,  // unused
    output ahbl_hreadyout_o,  // AHB ready signal
    output ahbl_hresp_o,  // Always 1 for this module
    input ahbl_hsel_i,  // AHB select
    input ahbl_hwrite_i,  // AHB write enable
    input clk_i, 
    input resetn_i) ;
    reg [(BUS_WIDTH - 1):0] r_gpio_o ; 
    reg [(BUS_WIDTH - 1):0] r_rval ; 
    reg [(BUS_WIDTH - 1):0] r_dir ; 
    wire [(BUS_WIDTH - 1):0] w_ioval ; 
    // I/F independent signals
    //reg [31:0]	r_rdata_o;
    wire [31:0] w_wdata_i ; 
    wire [15:0] w_wdata ; 
    wire [15:0] w_wdata_en ; 
    wire [3:0] w_addr ; 
    wire w_re ; 
    wire w_we ; 
    wire clk = clk_i ; 
    wire resetn = resetn_i ; 
    // AHBL I/F {{{
    // AHBL
    reg r_we ; 
    assign ahbl_hresp_o = 1'b0 ; 
    assign w_addr = ahbl_haddr_i[5:2] ; // same as LMMI
    assign w_re = ((ahbl_hsel_i && ahbl_htrans_i[1]) && (!ahbl_hwrite_i)) ; 
    assign w_we = r_we ; 
    assign ahbl_hreadyout_o = 1'b1 ; 
    assign w_wdata_i = ahbl_hwdata_i ; 
    assign w_wdata = ahbl_hwdata_i[(BUS_WIDTH - 1):0] ; 
    assign w_wdata_en = ahbl_hwdata_i[((BUS_WIDTH - 1) + 16):16] ; 
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_we <=  0 ;
                end
            else
                begin
                    r_we <=  ((ahbl_hsel_i && ahbl_htrans_i[1]) && ahbl_hwrite_i) ;
                end
        end
    //assign ahbl_hrdata_o = r_rdata_o;
    assign ahbl_hrdata_o[31:BUS_WIDTH] = 0 ; 
    assign ahbl_hrdata_o[(BUS_WIDTH - 1):0] = r_rval ; 
    assign gpo_o = r_gpio_o ; 
    assign gpi_o = w_ioval ; 
    assign int_o = 1'b0 ; 
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_rval <=  INIT_OUTVAL ;
                end
            else
                if (w_re) 
                    begin
                        if ((w_addr == 4'h00)) 
                            begin
                                r_rval <=  w_ioval ;
                            end
                        else
                            if ((w_addr == 4'h01)) 
                                begin
                                    r_rval <=  r_gpio_o ;
                                end
                            else
                                if ((w_addr == 4'h04)) 
                                    begin
                                        r_rval <=  r_dir ;
                                    end
                    end
        end
    // write
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_gpio_o <=  INIT_OUTVAL ;
                end
            else
                if (w_we) 
                    begin
                        if ((w_addr == 4'h01)) 
                            begin
                                r_gpio_o <=  ((r_gpio_o & (~w_wdata_en)) | (w_wdata & w_wdata_en)) ;
                            end
                        else
                            if ((w_addr == 4'h02)) 
                                begin
                                    r_gpio_o <=  (r_gpio_o | (w_wdata & w_wdata_en)) ;
                                end
                            else
                                if ((w_addr == 4'h03)) 
                                    begin
                                        r_gpio_o <=  (r_gpio_o & (~(w_wdata & w_wdata_en))) ;
                                    end
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_dir <=  DIRECTION ;
                end
            else
                if (w_we) 
                    begin
                        if ((w_addr == 4'h04)) 
                            begin
                                r_dir <=  ((r_dir & (~w_wdata_en)) | (w_wdata & w_wdata_en)) ;
                            end
                    end
        end
    // ***** interrupt related logics *****
    genvar i ; 
    for (i = 0;(i < BUS_WIDTH);i = (i + 1))
    begin : genblk1
        if ((DEVICE == "ICE40UP")) 
            begin : genblk1
                BB_B sb_io_i (.I(r_gpio_o[i]), 
                            .O(w_ioval[i]), 
                            .T_N(r_dir[i]), 
                            .B(gpio_io[i])) ; 
            end
        else
            if ((DEVICE == "CPNX")) 
                begin : genblk1
                    BB io_i (.I(r_gpio_o[i]), 
                                .O(w_ioval[i]), 
                                .T((~r_dir[i])), 
                                .B(gpio_io[i])) ; 
                end
            else
                begin : genblk1
                    assign w_ioval[i] = gpio_io[i] ; 
                    assign gpio_io[i] = ((~r_dir[i]) ? 1'bz : r_gpio_o[i]) ; 
                end
    end
endmodule


