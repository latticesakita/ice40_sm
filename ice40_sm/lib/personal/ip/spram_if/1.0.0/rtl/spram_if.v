
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Propel (64-bit)
    2025.1.0.2506031608
    Soft IP Version: 1.0.0
    2025 08 21 07:23:45
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="spram_if", LATTICE_IP_GENERATED="1" *) module spram_if (HCLK, 
        HRESETn, 
        HADDR, 
        HBURST, 
        HTRANS, 
        HSIZE, 
        HWRITE, 
        HSEL, 
        HREADY, 
        HWDATA, 
        HRDATA, 
        HREADYOUT, 
        HRESP, 
        sram_addr, 
        sram_we, 
        sram_maskwe, 
        sram_re, 
        sram_din, 
        sram_dout, 
        sram_write_done, 
        sram_read_valid) ;
    input HCLK ; 
    input HRESETn ; 
    input [31:0] HADDR ; 
    input [2:0] HBURST ; 
    input [1:0] HTRANS ; 
    input [2:0] HSIZE ; 
    input HWRITE ; 
    input HSEL ; 
    input HREADY ; 
    input [31:0] HWDATA ; 
    output [31:0] HRDATA ; 
    output HREADYOUT ; 
    output HRESP ; 
    output [31:0] sram_addr ; 
    output sram_we ; 
    output [3:0] sram_maskwe ; 
    output sram_re ; 
    output [31:0] sram_din ; 
    input [31:0] sram_dout ; 
    input sram_write_done ; 
    input sram_read_valid ; 
    spram_if_ipgen_ahb_spsram_nano ahb_spsram_nano_inst (.HCLK(HCLK), 
                .HRESETn(HRESETn), 
                .HADDR(HADDR[31:0]), 
                .HBURST(HBURST[2:0]), 
                .HTRANS(HTRANS[1:0]), 
                .HSIZE(HSIZE[2:0]), 
                .HWRITE(HWRITE), 
                .HSEL(HSEL), 
                .HREADY(HREADY), 
                .HWDATA(HWDATA[31:0]), 
                .HRDATA(HRDATA[31:0]), 
                .HREADYOUT(HREADYOUT), 
                .HRESP(HRESP), 
                .sram_addr(sram_addr[31:0]), 
                .sram_we(sram_we), 
                .sram_maskwe(sram_maskwe[3:0]), 
                .sram_re(sram_re), 
                .sram_din(sram_din[31:0]), 
                .sram_dout(sram_dout[31:0]), 
                .sram_write_done(sram_write_done), 
                .sram_read_valid(sram_read_valid)) ; 
endmodule



// support only single write, single read
// HSIZE is for write operation is not supported
// HSIZE is only for read operation
module spram_if_ipgen_ahb_spsram_nano (
    input HCLK, 
    input HRESETn, 
    input [31:0] HADDR, 
    input [2:0] HBURST, 
    input [1:0] HTRANS, 
    input [2:0] HSIZE, 
    input HWRITE, 
    input HSEL, 
    input HREADY, 
    input [31:0] HWDATA, 
    output [31:0] HRDATA, 
    output HREADYOUT, 
    output HRESP, 
    output [31:0] sram_addr, 
    output sram_we, 
    output [3:0] sram_maskwe, 
    output sram_re, 
    output [31:0] sram_din, 
    input [31:0] sram_dout, 
    input sram_write_done, 
    input sram_read_valid) ;
    reg sram_we_reg ; 
    reg hreadyout_reg ; 
    //wire ahb_access = HSEL && HREADY && HTRANS[1];
    wire ahb_access ; 
    assign ahb_access = (HSEL && HTRANS[1]) ; 
    assign sram_addr = {2'b0,
                HADDR[31:2]} ; 
    assign sram_we = sram_we_reg ; 
    assign sram_re = (ahb_access & (~HWRITE)) ; 
    assign sram_din = HWDATA ; 
    assign HRDATA = sram_dout ; 
    assign sram_maskwe = ((HSIZE[2:0] == 3'b000) ? (4'b0001 << HADDR[1:0]) : ((HSIZE[2:0] == 3'b001) ? (4'b0011 << (HADDR[1] * 2)) : 4'b1111)) ; 
    assign HREADYOUT = (hreadyout_reg | (sram_write_done | sram_read_valid)) ; 
    assign HRESP = 1'b0 ; 
    always
        @(posedge HCLK or 
            negedge HRESETn)
        begin
            if ((!HRESETn)) 
                begin
                    sram_we_reg <=  1'b0 ;
                end
            else
                if (ahb_access) 
                    begin
                        sram_we_reg <=  HWRITE ;
                    end
                else
                    begin
                        sram_we_reg <=  1'b0 ;
                    end
        end
    always
        @(posedge HCLK or 
            negedge HRESETn)
        begin
            if ((!HRESETn)) 
                begin
                    hreadyout_reg <=  1'b1 ;
                end
            else
                if (ahb_access) 
                    begin
                        hreadyout_reg <=  1'b0 ;
                    end
                else
                    if (((~hreadyout_reg) && (sram_write_done | sram_read_valid))) 
                        begin
                            hreadyout_reg <=  1'b1 ;
                        end
        end
endmodule


