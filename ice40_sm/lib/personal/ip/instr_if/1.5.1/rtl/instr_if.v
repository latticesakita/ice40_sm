
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Propel (64-bit)
    2025.1.0.2506031608
    Soft IP Version: 1.5.1
    2025 09 01 14:37:54
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="instr_if", LATTICE_IP_GENERATED="1" *) module instr_if (HCLK, 
        HRESETn, 
        HADDR, 
        HBURST, 
        HTRANS, 
        HSIZE, 
        HWRITE, 
        HSEL, 
        HREADY, 
        HWDATA, 
        HRDATA, 
        HREADYOUT, 
        HRESP, 
        sram_addr, 
        sram_we, 
        sram_re, 
        sram_din, 
        sram_dout, 
        sram_write_done, 
        sram_read_valid) ;
    input HCLK ; 
    input HRESETn ; 
    input [31:0] HADDR ; 
    input [2:0] HBURST ; 
    input [1:0] HTRANS ; 
    input [2:0] HSIZE ; 
    input HWRITE ; 
    input HSEL ; 
    input HREADY ; 
    input [31:0] HWDATA ; 
    output [31:0] HRDATA ; 
    output HREADYOUT ; 
    output HRESP ; 
    output [31:0] sram_addr ; 
    output sram_we ; 
    output sram_re ; 
    output [31:0] sram_din ; 
    input [31:0] sram_dout ; 
    input sram_write_done ; 
    input sram_read_valid ; 
    instr_if_ipgen_ahb_spsram_if ahb_spsram_if_inst (.HCLK(HCLK), 
                .HRESETn(HRESETn), 
                .HADDR(HADDR[31:0]), 
                .HBURST(HBURST[2:0]), 
                .HTRANS(HTRANS[1:0]), 
                .HSIZE(HSIZE[2:0]), 
                .HWRITE(HWRITE), 
                .HSEL(HSEL), 
                .HREADY(HREADY), 
                .HWDATA(HWDATA[31:0]), 
                .HRDATA(HRDATA[31:0]), 
                .HREADYOUT(HREADYOUT), 
                .HRESP(HRESP), 
                .sram_addr(sram_addr[31:0]), 
                .sram_we(sram_we), 
                .sram_re(sram_re), 
                .sram_din(sram_din[31:0]), 
                .sram_dout(sram_dout[31:0]), 
                .sram_write_done(sram_write_done), 
                .sram_read_valid(sram_read_valid)) ; 
endmodule



module instr_if_ipgen_ahb_spsram_if (
    input HCLK, 
    input HRESETn, 
    input [31:0] HADDR, 
    input [2:0] HBURST, 
    input [1:0] HTRANS, 
    input [2:0] HSIZE, 
    input HWRITE, 
    input HSEL, 
    input HREADY, 
    input [31:0] HWDATA, 
    output [31:0] HRDATA, 
    output HREADYOUT, 
    output HRESP, 
    output [31:0] sram_addr, 
    output sram_we, 
    output sram_re, 
    output [31:0] sram_din, 
    input [31:0] sram_dout, 
    input sram_write_done, 
    input sram_read_valid) ;
    // Burst type encoding
    localparam BURST_SINGLE = 3'b000 ; 
    localparam BURST_INCR = 3'b001 ; 
    localparam BURST_INCR4 = 3'b011 ; 
    localparam BURST_INCR8 = 3'b101 ; 
    reg [31:0] addr_reg, 
        next_addr ; 
    reg [2:0] burst_type ; 
    reg [2:0] burst_count ; 
    reg write_phase, 
        read_phase ; 
    reg hreadyout_reg ; 
    reg sram_we_reg, 
        sram_re_reg ; 
    reg [31:0] sram_din_reg ; 
    assign sram_addr = {2'b0,
                addr_reg[31:2]} ; 
    assign sram_we = sram_we_reg ; 
    assign sram_re = sram_re_reg ; 
    assign sram_din = sram_din_reg ; 
    assign HRDATA = sram_dout ; 
    assign HREADYOUT = hreadyout_reg ; 
    assign HRESP = 1'b0 ; 
    //wire ahb_access = HSEL && HREADY && HTRANS[1];
    wire ahb_access = (HSEL && HTRANS[1]) ; 
    // Burst length decoder
    function [2:0] burst_length ; 
        input [2:0] burst ; 
        case (burst)
        BURST_SINGLE : 
            burst_length = 3'd1 ;
        BURST_INCR : 
            burst_length = 3'd7 ;
        BURST_INCR4 : 
            // Arbitrary max burst
            burst_length = 3'd4 ;
        BURST_INCR8 : 
            burst_length = 3'd8 ;
        default : 
            burst_length = 3'd1 ;
        endcase 
    endfunction
    // Address incrementer
    function [31:0] increment_address ; 
        input [31:0] addr ; 
        increment_address = (addr + 4) ;
    endfunction
    always
        @(posedge HCLK or 
            negedge HRESETn)
        begin
            if ((!HRESETn)) 
                begin
                    addr_reg <=  32'b0 ;
                    burst_type <=  3'b0 ;
                    burst_count <=  3'b0 ;
                    write_phase <=  1'b0 ;
                    read_phase <=  1'b0 ;
                    hreadyout_reg <=  1'b1 ;
                    sram_we_reg <=  1'b0 ;
                    sram_re_reg <=  1'b0 ;
                end
            else
                begin
                    sram_we_reg <=  1'b0 ;
                    sram_re_reg <=  1'b0 ;
                    if (((ahb_access && (!write_phase)) && (!read_phase))) 
                        begin
                            addr_reg <=  HADDR ;
                            burst_type <=  HBURST ;
                            burst_count <=  burst_length(HBURST) ;
                            write_phase <=  HWRITE ;
                            read_phase <=  (~HWRITE) ;
                            sram_din_reg <=  HWDATA ;
                            hreadyout_reg <=  1'b0 ;
                            if (HWRITE) 
                                sram_we_reg <=  1'b1 ;
                            else
                                sram_re_reg <=  1'b1 ;
                        end
                    else
                        if ((write_phase && sram_write_done)) 
                            begin
                                burst_count <=  (burst_count - 1) ;
                                if ((burst_count > 1)) 
                                    begin
                                        addr_reg <=  increment_address(addr_reg) ;
                                        sram_we_reg <=  1'b1 ;
                                        hreadyout_reg <=  1'b0 ;
                                    end
                                else
                                    begin
                                        write_phase <=  1'b0 ;
                                        hreadyout_reg <=  1'b1 ;
                                    end
                            end
                        else
                            if ((read_phase && sram_read_valid)) 
                                begin
                                    burst_count <=  (burst_count - 1) ;
                                    if ((burst_count > 1)) 
                                        begin
                                            addr_reg <=  increment_address(addr_reg) ;
                                            sram_re_reg <=  1'b1 ;
                                            hreadyout_reg <=  1'b0 ;
                                        end
                                    else
                                        begin
                                            read_phase <=  1'b0 ;
                                            hreadyout_reg <=  1'b1 ;
                                        end
                                end
                            else
                                begin
                                    hreadyout_reg <=  1'b1 ;
                                end
                end
        end
endmodule


