
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Propel (64-bit)
    2025.1.0.2506031608
    Soft IP Version: 1.0.0
    2025 09 02 15:35:45
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="timer", LATTICE_IP_GENERATED="1" *) module timer (int_o, 
        ahbl_haddr_i, 
        ahbl_hburst_i, 
        ahbl_hrdata_o, 
        ahbl_hsize_i, 
        ahbl_htrans_i, 
        ahbl_hwdata_i, 
        ahbl_hready_i, 
        ahbl_hreadyout_o, 
        ahbl_hresp_o, 
        ahbl_hsel_i, 
        ahbl_hwrite_i, 
        systime_o, 
        clk_i, 
        resetn_i) ;
    output int_o ; 
    input [31:0] ahbl_haddr_i ; 
    input [2:0] ahbl_hburst_i ; 
    output [31:0] ahbl_hrdata_o ; 
    input [2:0] ahbl_hsize_i ; 
    input [1:0] ahbl_htrans_i ; 
    input [31:0] ahbl_hwdata_i ; 
    input ahbl_hready_i ; 
    output ahbl_hreadyout_o ; 
    output ahbl_hresp_o ; 
    input ahbl_hsel_i ; 
    input ahbl_hwrite_i ; 
    output [31:0] systime_o ; 
    input clk_i ; 
    input resetn_i ; 
    timer_ipgen_timer_ahbl #(.PRESCALE(11),
            .USE_DSP(1)) timer_ahbl_inst (.int_o(int_o), 
                .ahbl_haddr_i(ahbl_haddr_i[31:0]), 
                .ahbl_hburst_i(ahbl_hburst_i[2:0]), 
                .ahbl_hrdata_o(ahbl_hrdata_o[31:0]), 
                .ahbl_hsize_i(ahbl_hsize_i[2:0]), 
                .ahbl_htrans_i(ahbl_htrans_i[1:0]), 
                .ahbl_hwdata_i(ahbl_hwdata_i[31:0]), 
                .ahbl_hready_i(ahbl_hready_i), 
                .ahbl_hreadyout_o(ahbl_hreadyout_o), 
                .ahbl_hresp_o(ahbl_hresp_o), 
                .ahbl_hsel_i(ahbl_hsel_i), 
                .ahbl_hwrite_i(ahbl_hwrite_i), 
                .systime_o(systime_o[31:0]), 
                .clk_i(clk_i), 
                .resetn_i(resetn_i)) ; 
endmodule



// 8'b0000_0000: inta       :Alarm all (readonly)
// 8'b0000_0100: clocks     : Clocks if CLOCKS_EN is set
// 8'b0000_1000: ticks      : Ticks
// 8'b0000_1100: prescale   : Prescale
// 8'b0001_0000: int0       :Alarm0 / interrupts
// 8'b0001_0100: int1       :Alarm1 / interrupts
// 8'b0001_1000: int2       :Alarm2 / interrupts
// 8'b0001_1100: int3       :Alarm3 / interrupts
// 8'b0010_0000: repeat0_en : Alarm0 repeat enable
// 8'b0010_0100: repeat1_en : Alarm1 repeat enable
// 8'b0010_1000: repeat2_en : Alarm2 repeat enable
// 8'b0010_1100: repeat3_en : Alarm3 repeat enable
// 8'b0011_0000: set0       :Alarm0 set & enable
// 8'b0011_0100: set1       :Alarm1 set & enable
// 8'b0011_1000: set2       :Alarm2 set & enable
// 8'b0011_1100: set3       :Alarm3 set & enable
// 8'b0100_0000: end0       :Alarm0 end time
// 8'b0100_0100: end1       :Alarm1 end time
// 8'b0100_1000: end2       :Alarm2 end time
// 8'b0100_1100: end3       :Alarm3 end time
// 8'b0101_0000: en0        :Alarm0 enable/disable
// 8'b0101_0100: en1        :Alarm1 enable/disable
// 8'b0101_1000: en2        :Alarm2 enable/disable
// 8'b0101_1100: en3        :Alarm3 enable/disable
// 8'b0110_0000: int0_en    :Alarm0 interrupt enable/disable
// 8'b0110_0100: int1_en    :Alarm1 interrupt enable/disable
// 8'b0110_1000: int2_en    :Alarm2 interrupt enable/disable
// 8'b0110_1100: int3_en    :Alarm3 interrupt enable/disable
//`define CLOCKS_EN
module timer_ipgen_timer_ahbl #(parameter PRESCALE = (24 - 1), 
        parameter USE_DSP = 1) (
    output int_o, 
    input [31:0] ahbl_haddr_i, 
    input [2:0] ahbl_hburst_i, 
    output [31:0] ahbl_hrdata_o, 
    input [2:0] ahbl_hsize_i, 
    input [1:0] ahbl_htrans_i, 
    input [31:0] ahbl_hwdata_i, 
    input ahbl_hready_i, 
    output ahbl_hreadyout_o, 
    output ahbl_hresp_o, 
    input ahbl_hsel_i, 
    input ahbl_hwrite_i, 
    output [31:0] systime_o, 
    input clk_i, 
    input resetn_i) ;
    localparam NUM_OF_TIMERS = 2 ; 
    // I/F independent signals
    reg [31:0] r_rdata_o ; 
    wire [31:0] w_wdata_i ; 
    wire [31:0] w_addr ; 
    wire w_re ; 
    wire w_we ; 
    wire access_en ; 
    wire clk ; 
    wire resetn ; 
    assign clk = clk_i ; 
    assign resetn = resetn_i ; 
    // AHBL I/F {{{
    // AHBL
    reg r_we ; 
    reg r_re ; 
    reg [7:0] r_addr ; 
    assign ahbl_hresp_o = 1'b0 ; 
    assign w_addr = {24'b0,
                r_addr} ; // ahbl_haddr_i;
    assign access_en = (ahbl_hsel_i && ahbl_htrans_i[1]) ; 
    assign w_re = ((ahbl_hsel_i && ahbl_htrans_i[1]) && (!ahbl_hwrite_i)) ; 
    assign w_we = r_we ; 
    assign ahbl_hreadyout_o = (~(r_we | r_re)) ; 
    assign ahbl_hrdata_o = r_rdata_o ; 
    assign w_wdata_i = ahbl_hwdata_i ; 
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_we <=  0 ;
                    r_re <=  0 ;
                    r_addr <=  0 ;
                end
            else
                begin
                    r_we <=  ((ahbl_hsel_i && ahbl_htrans_i[1]) && ahbl_hwrite_i) ;
                    r_re <=  ((ahbl_hsel_i && ahbl_htrans_i[1]) && (~ahbl_hwrite_i)) ;
                    r_addr <=  ahbl_haddr_i[7:0] ;
                end
        end
    // AHBL I/F }}}
    reg [2:0] r_rst = 3'b000 ; 
    reg [1:0] r_alarm_enable ; 
    reg [1:0] r_alarm_repeat ; 
    reg [1:0] r_alarm_int ; 
    reg [1:0] r_alarm_int_en ; 
    //reg [31:0]	r_alarm0_set;
    reg [31:0] r_alarm0_end ; 
    reg [31:0] r_alarm1_set ; 
    reg [31:0] r_alarm1_end ; 
    wire w_enable ; 
    wire [31:0] w_ticks ; // ticks at every PRESCALE, if clock is 24MHz and PRESCALE=24000-1, this will be milli sec.
    wire [31:0] w_alarm_end ; 
    wire [31:0] w_alarm_set ; 
    reg [7:0] r_prescale ; 
    wire [7:0] w_tick_cnt ; 
    wire w_tick_reload ; 
    wire w_alarm0_fire ; 
    wire w_alarm1_fire ; 
    assign w_tick_reload = ((w_tick_cnt == r_prescale) ? 1'b1 : 1'b0) ; 
    assign int_o = (|(r_alarm_int & r_alarm_int_en)) ; 
    assign systime_o = w_ticks ; 
    assign w_alarm0_fire = (w_ticks == r_alarm0_end) ; 
    assign w_alarm1_fire = (w_ticks == r_alarm1_end) ; 
    assign w_enable = r_rst[2] ; 
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_rst <=  0 ;
                end
            else
                begin
                    r_rst <=  {r_rst[1:0],
                            1'b1} ;
                end
        end
    reg [31:0] r_alarm_set ; 
    reg [3:0] r_alarm_end_valid ; 
    // reg [3:0] r_alarm_end_valid_m;
    // always @(posedge clk or negedge resetn) begin
    // 	if(!resetn) begin
    // 		r_alarm_end_valid <= 0;
    // 	end
    // 	else begin
    // 		r_alarm_end_valid <= r_alarm_end_valid_m;
    // 	end
    // end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_set <=  32'b1 ;
                    r_alarm_end_valid <=  4'b0 ;
                end
            else
                //else if(w_alarm0_fire && r_alarm_repeat[0]) begin
                //	r_alarm_set       <= r_alarm0_set;
                //	r_alarm_end_valid <= 4'b0001;
                //end
                if ((w_alarm1_fire && r_alarm_repeat[1])) 
                    begin
                        r_alarm_set <=  r_alarm1_set ;
                        r_alarm_end_valid <=  4'b0010 ;
                    end
                else
                    if ((w_we && (w_addr[7:4] == 4'b0011))) 
                        begin
                            r_alarm_set <=  w_wdata_i ;
                            r_alarm_end_valid[0] <=  (w_addr[3:2] == 2'b00) ;
                            r_alarm_end_valid[1] <=  (w_addr[3:2] == 2'b01) ;
                        end
                    else
                        if ((w_we && (w_addr[7:4] == 4'b0101))) 
                            begin
                                r_alarm_set <=  w_wdata_i ;
                                r_alarm_end_valid[0] <=  (w_addr[3:2] == 2'b00) ;
                                r_alarm_end_valid[1] <=  (w_addr[3:2] == 2'b01) ;
                            end
                        else
                            begin
                                r_alarm_end_valid <=  4'b0 ;
                            end
        end
    assign w_alarm_set = r_alarm_set ; 
    //assign w_alarm_set = 
    //	(w_alarm1_fire && r_alarm_repeat[1]) ? r_alarm1_set :
    //	(w_we && (w_addr[7:4]==4'b0011))     ? w_wdata_i :
    //	(w_we && (w_addr[7:4]==4'b0101))     ? w_wdata_i : 32'd1;
    generate
        if ((USE_DSP == 1)) 
            begin : genblk1
                reg [7:0] r_tick_cnt ; 
                assign w_tick_cnt = r_tick_cnt ; 
                always
                    @(posedge clk or 
                        negedge resetn)
                    begin
                        if ((!resetn)) 
                            begin
                                r_tick_cnt <=  0 ;
                            end
                        else
                            if (w_tick_reload) 
                                begin
                                    r_tick_cnt <=  0 ;
                                end
                            else
                                begin
                                    r_tick_cnt <=  (r_tick_cnt + 1) ;
                                end
                    end
                timer_ipgen_timer_dsp_acc32 ticks_i (.clk(clk), 
                            .resetn(resetn), 
                            .enable(w_tick_reload), 
                            .load((~w_enable)), 
                            .load_val(32'd0), 
                            .d(32'd1), 
                            .acc(w_ticks)) ; 
                timer_ipgen_timer_dsp_add32 alarm_end_i (.clk(clk), 
                            .resetn(resetn), 
                            .A(w_ticks), 
                            .B(w_alarm_set), 
                            .O(w_alarm_end)) ; 
            end
        else
            begin : genblk1
                reg [31:0] r_ticks ; 
                reg [7:0] r_tick_cnt ; 
                assign w_ticks = r_ticks ; 
                assign w_tick_cnt = r_tick_cnt ; 
                always
                    @(posedge clk or 
                        negedge resetn)
                    begin
                        if ((!resetn)) 
                            begin
                                r_tick_cnt <=  0 ;
                            end
                        else
                            if (w_tick_reload) 
                                begin
                                    r_tick_cnt <=  0 ;
                                end
                            else
                                begin
                                    r_tick_cnt <=  (r_tick_cnt + 1) ;
                                end
                    end
                always
                    @(posedge clk or 
                        negedge resetn)
                    begin
                        if ((!resetn)) 
                            begin
                                r_ticks <=  0 ;
                            end
                        else
                            if (w_tick_reload) 
                                begin
                                    r_ticks <=  (r_ticks + 1) ;
                                end
                    end
                assign w_alarm_end = (w_ticks + w_alarm_set) ; 
            end
    endgenerate
    // TIMER
    // **** READ ACCESS ****
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_rdata_o <=  32'h00 ;
                end
            else
                if (w_re) 
                    begin
                        case (w_addr[7:2])
                        6'b0000_00 : 
                            r_rdata_o <=  {24'b0,
                                    r_alarm_int} ;
                        6'b0000_10 : 
                            r_rdata_o <=  w_ticks ;
                        6'b0000_11 : 
                            r_rdata_o <=  {24'b0,
                                    r_prescale} ;
                        6'b0001_00 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_int[0]} ;
                        6'b0001_01 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_int[1]} ;
                        6'b0010_00 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_repeat[0]} ;
                        6'b0010_01 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_repeat[1]} ;
                        6'b0011_01 : 
                            //6'b0011_00: r_rdata_o <= r_alarm0_set;
                            r_rdata_o <=  r_alarm1_set ;
                        6'b0100_00 : 
                            r_rdata_o <=  r_alarm0_end ;
                        6'b0100_01 : 
                            r_rdata_o <=  r_alarm1_end ;
                        6'b0101_00 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_enable[0]} ;
                        6'b0101_01 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_enable[1]} ;
                        6'b0110_00 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_int_en[0]} ;
                        6'b0110_01 : 
                            r_rdata_o <=  {31'b0,
                                    r_alarm_int_en[1]} ;
                        default : 
                            r_rdata_o <=  0 ;
                        endcase 
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_int_en[0] <=  0 ;
                end
            else
                if ((w_we && (w_addr[7:2] == 6'b0110_00))) 
                    begin
                        r_alarm_int_en[0] <=  w_wdata_i[0] ;
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_int_en[1] <=  0 ;
                end
            else
                if ((w_we && (w_addr[7:2] == 6'b0110_01))) 
                    begin
                        r_alarm_int_en[1] <=  w_wdata_i[0] ;
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_int[0] <=  0 ;
                end
            else
                if ((access_en && (w_addr[7:2] == 6'b0001_00))) 
                    begin
                        r_alarm_int[0] <=  0 ;
                    end
                else
                    if (w_alarm0_fire) 
                        begin
                            r_alarm_int[0] <=  (r_alarm_enable[0] | r_alarm_int[0]) ;
                        end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_int[1] <=  0 ;
                end
            else
                if ((access_en && (w_addr[7:2] == 6'b0001_01))) 
                    begin
                        r_alarm_int[1] <=  0 ;
                    end
                else
                    if (w_alarm1_fire) 
                        begin
                            r_alarm_int[1] <=  (r_alarm_enable[1] | r_alarm_int[1]) ;
                        end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_prescale <=  PRESCALE ;
                end
            else
                if (w_we) 
                    begin
                        if ((w_addr[7:2] == 6'b0000_11)) 
                            begin
                                r_prescale <=  w_wdata_i[7:0] ;
                            end
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_enable[0] <=  0 ;
                    r_alarm_repeat[0] <=  0 ;
                end
            else
                if (w_alarm0_fire) 
                    begin
                        r_alarm_enable[0] <=  r_alarm_repeat[0] ;
                    end
                else
                    if (w_we) 
                        begin
                            if ((w_addr[7:2] == 6'b0011_00)) 
                                begin
                                    r_alarm_enable[0] <=  1'b1 ;
                                end
                            else
                                if ((w_addr[7:2] == 6'b0101_00)) 
                                    begin
                                        r_alarm_enable[0] <=  w_wdata_i[0] ;
                                    end
                                else
                                    if ((w_addr[7:2] == 6'b0010_00)) 
                                        begin
                                            r_alarm_repeat[0] <=  w_wdata_i[0] ;
                                        end
                        end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm_enable[1] <=  0 ;
                    r_alarm_repeat[1] <=  0 ;
                end
            else
                if (w_alarm1_fire) 
                    begin
                        r_alarm_enable[1] <=  r_alarm_repeat[1] ;
                    end
                else
                    if (w_we) 
                        begin
                            if ((w_addr[7:2] == 6'b0011_01)) 
                                begin
                                    r_alarm_enable[1] <=  1'b1 ;
                                end
                            else
                                if ((w_addr[7:2] == 6'b0101_01)) 
                                    begin
                                        r_alarm_enable[1] <=  w_wdata_i[0] ;
                                    end
                                else
                                    if ((w_addr[7:2] == 6'b0010_01)) 
                                        begin
                                            r_alarm_repeat[1] <=  w_wdata_i[0] ;
                                        end
                        end
        end
    //always @(posedge clk or negedge resetn) begin
    //	if(!resetn) begin
    //		r_alarm0_set <= 0;
    //	end
    //	else if(w_we) begin
    //		if(w_addr[7:2] == 6'b0011_00) begin
    //			r_alarm0_set <= w_wdata_i;
    //		end
    //	end
    //end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm1_set <=  0 ;
                end
            else
                if (w_we) 
                    begin
                        if ((w_addr[7:2] == 6'b0011_01)) 
                            begin
                                r_alarm1_set <=  w_wdata_i ;
                            end
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm0_end <=  0 ;
                end
            else
                if (r_alarm_end_valid[0]) 
                    begin
                        r_alarm0_end <=  w_alarm_end ;
                    end
        end
    always
        @(posedge clk or 
            negedge resetn)
        begin
            if ((!resetn)) 
                begin
                    r_alarm1_end <=  0 ;
                end
            else
                if (r_alarm_end_valid[1]) 
                    begin
                        r_alarm1_end <=  w_alarm_end ;
                    end
        end
endmodule



//32 bit ACCUMULATOR: 32 bit input, 32 bit output Accumulator
module timer_ipgen_timer_dsp_acc32 (
    input clk, 
    input resetn, 
    input enable, 
    input load, 
    input [31:0] load_val, 
    input [31:0] d, 
    output [31:0] acc) ;
    MAC16 #(.B_SIGNED("0b0"),
            .A_SIGNED("0b0"),
            .MODE_8x8("0b1"),
            .BOTADDSUB_CARRYSELECT("0b00"),
            .BOTADDSUB_UPPERINPUT("0b0"),
            .BOTADDSUB_LOWERINPUT("0b00"),
            .BOTOUTPUT_SELECT("0b01"),
            .TOPADDSUB_CARRYSELECT("0b10"),
            .TOPADDSUB_UPPERINPUT("0b0"),
            .TOPADDSUB_LOWERINPUT("0b00"),
            .TOPOUTPUT_SELECT("0b01"),
            .PIPELINE_16x16_MULT_REG2("0b0"),
            .PIPELINE_16x16_MULT_REG1("0b0"),
            .BOT_8x8_MULT_REG("0b0"),
            .TOP_8x8_MULT_REG("0b0"),
            .D_REG("0b0"),
            .B_REG("0b0"),
            .A_REG("0b0"),
            .C_REG("0b0")) mac16_acc_32_bypassed_unsigned_i (// C24
            // C23
            // C22
            // C20,C21
            // C19
            // C17,C18
            // C15,C16
            // C13,C14
            // C12
            // C10,C11
            // C8,C9
            // C7
            // C6
            // C5
            // C4
            // C3
            // C2
            // C1
            // C0
            .A0(d[16]), 
                .A1(d[17]), 
                .A2(d[18]), 
                .A3(d[19]), 
                .A4(d[20]), 
                .A5(d[21]), 
                .A6(d[22]), 
                .A7(d[23]), 
                .A8(d[24]), 
                .A9(d[25]), 
                .A10(d[26]), 
                .A11(d[27]), 
                .A12(d[28]), 
                .A13(d[29]), 
                .A14(d[30]), 
                .A15(d[31]), 
                .B0(d[0]), 
                .B1(d[1]), 
                .B2(d[2]), 
                .B3(d[3]), 
                .B4(d[4]), 
                .B5(d[5]), 
                .B6(d[6]), 
                .B7(d[7]), 
                .B8(d[8]), 
                .B9(d[9]), 
                .B10(d[10]), 
                .B11(d[11]), 
                .B12(d[12]), 
                .B13(d[13]), 
                .B14(d[14]), 
                .B15(d[15]), 
                .C0(load_val[16]), 
                .C1(load_val[17]), 
                .C2(load_val[18]), 
                .C3(load_val[19]), 
                .C4(load_val[20]), 
                .C5(load_val[21]), 
                .C6(load_val[22]), 
                .C7(load_val[23]), 
                .C8(load_val[24]), 
                .C9(load_val[25]), 
                .C10(load_val[26]), 
                .C11(load_val[27]), 
                .C12(load_val[28]), 
                .C13(load_val[29]), 
                .C14(load_val[30]), 
                .C15(load_val[31]), 
                .D0(load_val[0]), 
                .D1(load_val[1]), 
                .D2(load_val[2]), 
                .D3(load_val[3]), 
                .D4(load_val[4]), 
                .D5(load_val[5]), 
                .D6(load_val[6]), 
                .D7(load_val[7]), 
                .D8(load_val[8]), 
                .D9(load_val[9]), 
                .D10(load_val[10]), 
                .D11(load_val[11]), 
                .D12(load_val[12]), 
                .D13(load_val[13]), 
                .D14(load_val[14]), 
                .D15(load_val[15]), 
                .O0(acc[0]), 
                .O1(acc[1]), 
                .O2(acc[2]), 
                .O3(acc[3]), 
                .O4(acc[4]), 
                .O5(acc[5]), 
                .O6(acc[6]), 
                .O7(acc[7]), 
                .O8(acc[8]), 
                .O9(acc[9]), 
                .O10(acc[10]), 
                .O11(acc[11]), 
                .O12(acc[12]), 
                .O13(acc[13]), 
                .O14(acc[14]), 
                .O15(acc[15]), 
                .O16(acc[16]), 
                .O17(acc[17]), 
                .O18(acc[18]), 
                .O19(acc[19]), 
                .O20(acc[20]), 
                .O21(acc[21]), 
                .O22(acc[22]), 
                .O23(acc[23]), 
                .O24(acc[24]), 
                .O25(acc[25]), 
                .O26(acc[26]), 
                .O27(acc[27]), 
                .O28(acc[28]), 
                .O29(acc[29]), 
                .O30(acc[30]), 
                .O31(acc[31]), 
                .CLK(clk), 
                .CE(resetn), 
                .IRSTTOP((~resetn)), 
                .IRSTBOT((~resetn)), 
                .ORSTTOP((~resetn)), 
                .ORSTBOT((~resetn)), 
                .AHOLD(1'b0), 
                .BHOLD(1'b0), 
                .CHOLD(1'b0), 
                .DHOLD(1'b0), 
                .OLOADTOP(load), 
                .OLOADBOT(load), 
                .OHOLDTOP((~enable)), 
                .OHOLDBOT((~enable)), 
                .ADDSUBTOP(1'b0), 
                .ADDSUBBOT(1'b0), 
                .CO(), 
                .CI(1'b0), 
                //MAC cascading ports.
            .ACCUMCI(1'b0), 
                .ACCUMCO(), 
                .SIGNEXTIN(1'b0), 
                .SIGNEXTOUT()) ; 
endmodule



//32 bit ADDSUB: 32 bit input, 32 bit output ADDSUB
module timer_ipgen_timer_dsp_add32 (
    input clk, 
    input resetn, 
    input [31:0] A, 
    input [31:0] B, 
    output [31:0] O) ;
    MAC16 #(.B_SIGNED("0b0"),
            .A_SIGNED("0b0"),
            .MODE_8x8("0b1"),
            .BOTADDSUB_CARRYSELECT("0b00"),
            .BOTADDSUB_UPPERINPUT("0b1"),
            .BOTADDSUB_LOWERINPUT("0b00"),
            .BOTOUTPUT_SELECT("0b00"),
            .TOPADDSUB_CARRYSELECT("0b10"),
            .TOPADDSUB_UPPERINPUT("0b1"),
            .TOPADDSUB_LOWERINPUT("0b00"),
            .TOPOUTPUT_SELECT("0b00"),
            .PIPELINE_16x16_MULT_REG2("0b0"),
            .PIPELINE_16x16_MULT_REG1("0b0"),
            .BOT_8x8_MULT_REG("0b0"),
            .TOP_8x8_MULT_REG("0b0"),
            .D_REG("0b0"),
            .B_REG("0b0"),
            .A_REG("0b0"),
            .C_REG("0b0")) mac16_add_sub_32_bypassed_unsigned_reg_i (// C24
            // C23
            // C22
            // C20,C21
            // C19
            // C17,C18
            // C15,C16
            // C13,C14
            // C12
            // C10,C11
            // C8,C9
            // C7
            // C6
            // C5
            // C4
            // C3
            // C2
            // C1
            // C0
            .A0(A[16]), 
                .A1(A[17]), 
                .A2(A[18]), 
                .A3(A[19]), 
                .A4(A[20]), 
                .A5(A[21]), 
                .A6(A[22]), 
                .A7(A[23]), 
                .A8(A[24]), 
                .A9(A[25]), 
                .A10(A[26]), 
                .A11(A[27]), 
                .A12(A[28]), 
                .A13(A[29]), 
                .A14(A[30]), 
                .A15(A[31]), 
                .B0(A[0]), 
                .B1(A[1]), 
                .B2(A[2]), 
                .B3(A[3]), 
                .B4(A[4]), 
                .B5(A[5]), 
                .B6(A[6]), 
                .B7(A[7]), 
                .B8(A[8]), 
                .B9(A[9]), 
                .B10(A[10]), 
                .B11(A[11]), 
                .B12(A[12]), 
                .B13(A[13]), 
                .B14(A[14]), 
                .B15(A[15]), 
                .C0(B[16]), 
                .C1(B[17]), 
                .C2(B[18]), 
                .C3(B[19]), 
                .C4(B[20]), 
                .C5(B[21]), 
                .C6(B[22]), 
                .C7(B[23]), 
                .C8(B[24]), 
                .C9(B[25]), 
                .C10(B[26]), 
                .C11(B[27]), 
                .C12(B[28]), 
                .C13(B[29]), 
                .C14(B[30]), 
                .C15(B[31]), 
                .D0(B[0]), 
                .D1(B[1]), 
                .D2(B[2]), 
                .D3(B[3]), 
                .D4(B[4]), 
                .D5(B[5]), 
                .D6(B[6]), 
                .D7(B[7]), 
                .D8(B[8]), 
                .D9(B[9]), 
                .D10(B[10]), 
                .D11(B[11]), 
                .D12(B[12]), 
                .D13(B[13]), 
                .D14(B[14]), 
                .D15(B[15]), 
                .O0(O[0]), 
                .O1(O[1]), 
                .O2(O[2]), 
                .O3(O[3]), 
                .O4(O[4]), 
                .O5(O[5]), 
                .O6(O[6]), 
                .O7(O[7]), 
                .O8(O[8]), 
                .O9(O[9]), 
                .O10(O[10]), 
                .O11(O[11]), 
                .O12(O[12]), 
                .O13(O[13]), 
                .O14(O[14]), 
                .O15(O[15]), 
                .O16(O[16]), 
                .O17(O[17]), 
                .O18(O[18]), 
                .O19(O[19]), 
                .O20(O[20]), 
                .O21(O[21]), 
                .O22(O[22]), 
                .O23(O[23]), 
                .O24(O[24]), 
                .O25(O[25]), 
                .O26(O[26]), 
                .O27(O[27]), 
                .O28(O[28]), 
                .O29(O[29]), 
                .O30(O[30]), 
                .O31(O[31]), 
                .CLK(clk), 
                .CE(resetn), 
                .IRSTTOP((~resetn)), 
                .IRSTBOT((~resetn)), 
                .ORSTTOP((~resetn)), 
                .ORSTBOT((~resetn)), 
                .AHOLD(1'b0), 
                .BHOLD(1'b0), 
                .CHOLD(1'b0), 
                .DHOLD(1'b0), 
                .OLOADTOP(1'b0), 
                .OLOADBOT(1'b0), 
                .OHOLDTOP(1'b0), 
                .OHOLDBOT(1'b0), 
                .ADDSUBTOP(1'b0), 
                .ADDSUBBOT(1'b0), 
                .CO(), 
                .CI(1'b0), 
                //MAC cascading ports.
            .ACCUMCI(1'b0), 
                .ACCUMCO(), 
                .SIGNEXTIN(1'b0), 
                .SIGNEXTOUT()) ; 
endmodule


