// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2025 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

#include "hal.h"
#include "utils.h"
#include <stdio.h>
#include "sys_platform.h"
#include <riscv_errors.h>
#include "platform_init.h"
#include "device_info.h"

#if REG_TEST_ENABLE
#include "reg_test.h"
#endif

#ifdef TERM_UART_INST_BASE_ADDR
#include "uart.h"

#ifndef _UART_NO_INTERRUPTS_
#include "pic.h"
#endif
#endif

#ifdef LED_GPIO_INST_BASE_ADDR
#include "gpio.h"
#define LED_COUNT 8
struct gpio_instance led_gpio_inst;
#else
#define LED_COUNT 8
#endif

//#include "timer.h"
#include "timer2.h"
#include "pic.h"
#include "lib_ov08x.h"

#define GPIO_INTERVAL    500000 // 1500(1.5ms) for simulation, 500000(500ms) for target, less than 1ms won't work due to slow processing speed
//#define GPIO_INTERVAL    1500 // 1500(1.5ms) for simulation, 500000(500ms) for target, less than 1ms won't work due to slow processing speed
#define TIMER_PRESCALE 23

#if (defined TERM_UART_INST_BASE_ADDR)
struct uart_instance term_uart_core_uart;
#elif (defined TERM_LOCAL_UART_INST_BASE_ADDR)
struct local_uart_instance term_local_uart_core;
#endif

static int lscc_uart_putc(char c, FILE *file)
{
#ifdef LSCC_STDIO_UART_APB
		int ret = EOF;
#if (defined TERM_UART_INST_BASE_ADDR)
		ret = uart_putc(&term_uart_core_uart, c);
		//if (c == '\n' && ret == 0)
			//ret = uart_putc(&term_uart_core_uart, '\r');
#elif (defined TERM_LOCAL_UART_INST_BASE_ADDR)
		ret = local_uart_putc(&term_local_uart_core, c);
		if (c == '\n' && ret == 0)
			ret = local_uart_putc(&term_local_uart_core, '\r');
#endif
		return ret;
#else
		return EOF;
#endif
}


static int lscc_uart_getc(FILE *file)
{
	(void) file;
	return EOF;
}


static int lscc_uart_flush(FILE *file)
{
	(void) file;
	return 0;
}


static int bsp_init(void)
{
	int ret = 0;
	pic_init(CPU_INST_0_PICTIMER_START_ADDR);
#if (defined TERM_UART_INST_BASE_ADDR)
#ifndef _UART_NO_INTERRUPTS_
	//setup uart IRQ
	pic_init(CPU_INST_0_PICTIMER_START_ADDR);
	term_uart_core_uart.intrLevel = TERM_UART_INST_IRQ;
	term_uart_core_uart.intrAvail = true;
	//pic_isr_register(UART0_INST_IRQ, uart_isr, (void *)&term_uart_core_uart);
#endif

	//initialize UART
	uart_init(&term_uart_core_uart, TERM_UART_INST_BASE_ADDR, TERM_UART_INST_SYS_CLK * 1000000, TERM_UART_INST_BAUD_RATE, 1, 8);
#elif (defined TERM_LOCAL_UART_INST_BASE_ADDR)
    local_uart_init(&term_local_uart_core, TERM_LOCAL_UART_INST_BASE_ADDR, TERM_LOCAL_UART_INST_SYS_CLK * 1000000, TERM_LOCAL_UART_INST_BAUD_RATE, 1, 8);
#endif
	iob_init(lscc_uart_putc, lscc_uart_getc, lscc_uart_flush);

#if CPU_INST_0_PLIC_EN || CPU_INST_0_CLINT_EN
	trap_init();
#endif

#if REG_TEST_ENABLE
	/* Used for register access test, If not sure how to use, disable it. */
	reg_test_assert(mem_access_test());
	printf("\nmem_access_test success!\n\n");
#endif

#ifdef LED_GPIO_INST_BASE_ADDR
	//initialize LED GPIO
	//led_gpio_inst.instance_name = LED_GPIO_INST_NAME;
	gpio_init(&led_gpio_inst, LED_GPIO_INST_BASE_ADDR, LED_GPIO_INST_LINES_NUM, LED_GPIO_INST_GPIO_DIRS);
#endif

#ifdef RISCV_RX_DRV_VER
	/*If driver support, set global interrupt-enable bit to 1.*/
#if CPU_INST_0_PLIC_EN || CPU_INST_0_CLINT_EN
	plic_enable_global_interrupts(1);
#endif
#endif
	return ret;
}

static void every500ms(void)
{
	static uint16_t pin_state = 0;
	static unsigned int s = 1;
	uint16_t pin_val;

	pin_state = ~pin_state;
	s++;
	pin_val = ((s & 0x7F)<<1) | (pin_state & 0x0001);

	gpio_output_write(&led_gpio_inst, GPIO0|GPIO1|GPIO2|GPIO3|GPIO4|GPIO5, pin_val);

#if 0
	static uint8_t print_en = 0;
	if(print_en ==0){
		print_en=1;
	}
	else{
		print_en=0;
		log_printf(&uart_core_uart, 1, "%d sec\n", s++);
	}
#endif
}

int main(void) {
	static uint16_t idx = GPIO4;
	static uint16_t pin_state;

	bsp_init();
	
	pic_isr_register(S_INT_TIMER, timer2_isr, NULL);
#ifdef TIMER_INST_BASE_ADDR
	timer2_init(TIMER_INST_BASE_ADDR, TIMER_PRESCALE);
	gpio_set_direction(&led_gpio_inst, GPIO0|GPIO1|GPIO2|GPIO3|GPIO4|GPIO5, GPIO_OUTPUT);
	timer2_register(TIMER1_SRC, every500ms);
	timer2_set(TIMER1_SRC, GPIO_INTERVAL, TIMER_REPEAT);

#endif
	log_puts(&term_uart_core_uart, 1, "Started!\nHello RISC-V world!\n");
	//log_printf(&term_uart_core_uart, 1, "Started!\nHello RISC-V world!\n");
	//printf("Started!\nHello RISC-V world!\n");
	ov08x_start(&led_gpio_inst, I2C_SLAVE_OV08X);

	while (true);

	return 0;
}

